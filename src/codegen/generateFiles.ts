import prettier from 'prettier'
import { log } from '../utils'
import { zx } from '../zodx'
import { CategorisedAddressImport } from './buildCategorisedAddressImports'
import { FileDescriptionsByCategory } from './buildFileDescriptions'
import { capitalize } from '../utils'

const preamble = '// THIS FILE IS AUTOGENERATED - DO NOT EDIT'
const defaultImportLabel = `import { Address, isAddress } from "./address"`

const ethersImportLabel = (
  importBigNumber: boolean,
) => `import type { Signer } from "ethers";
import type { Provider } from "@ethersproject/providers";
${importBigNumber ? `import { BigNumber } from "ethers"` : ''}`

const contractFactoryImportLabel = (contractFactory: string) =>
  `import { ${contractFactory} } from "./contracts"`

const addressImportLabel = ({
  path,
  addressConstants,
  addressType,
}: CategorisedAddressImport) =>
  `import { ${addressConstants.join(
    ', ',
  )} } from "${path}"\nimport type { ${addressType} } from "${path}"`

const addressTypeLabel = (addressType: string) =>
  `export type ${addressType} = Address & { readonly ${addressType}: unique symbol }`

const addressConstLabel = (
  address: zx.Address,
  addressConstant: string,
  addressType: string,
) => `export const ${addressConstant} = "${address}" as ${addressType}`

const addressListLabel = (category: string, addressConsts: string[]) =>
  `export const ${category}List = [\n${addressConsts.join(',\n')}]`

const addressGuardLabel = (
  category: string,
  addressType: string,
  isUnique: boolean,
  addressConsts: string[],
) =>
  `export const is${addressType} = (address: string): address is ${addressType} => isAddress(address) && ${
    isUnique
      ? `address === ${addressConsts[0]}`
      : `${category}List.some((${category}Address) => ${category}Address === address)`
  }`

const contractLabel = (
  category: string,
  addressType: string,
  contractFactory: string,
) =>
  `export const ${category}Contract = (address: ${addressType}, signerOrProvider: Signer | Provider) => ${contractFactory}.connect(address, signerOrProvider)`

const metadataTypeLabel = (
  category: string,
  addressType: string,
  metadataType: string,
) =>
  `export type ${capitalize(
    category,
  )}Metadata = Record<${addressType}, ${metadataType}>`

const metadataLabel = (
  category: string,
  addresses: zx.Address[],
  addressConstantsByAddress: Record<zx.Address, string>,
  metadataEntriesByAddress: Record<zx.Address, string>,
) => {
  let label = `export const ${category}Metadata: ${capitalize(
    category,
  )}Metadata = {\n`
  for (const address of addresses) {
    label += `[${addressConstantsByAddress[address]}]: ${metadataEntriesByAddress[address]},\n`
  }
  return label + `}`
}

export function generateFiles(
  categories: [string, ...string[]],
  fileDescriptionsByCategory: FileDescriptionsByCategory,
): Record<string, string> {
  const fileByCategory: Record<string, string> = {}

  for (const category of categories) {
    const {
      addresses,
      contractFactory,
      addressImports,
      addressConstantsByAddress,
      isUnique,
      addressType,
      metadataType,
      importBigNumber,
      metadataEntriesByAddress,
    } = fileDescriptionsByCategory[category]

    const imports = [
      defaultImportLabel,
      ethersImportLabel(importBigNumber),
      contractFactoryImportLabel(contractFactory),
      ...addressImports.map(addressImportLabel),
    ].join('\n')

    const addressConsts = addresses.map(
      (address) => addressConstantsByAddress[address],
    )

    const addressConstLabels = addresses
      .map((address) =>
        addressConstLabel(
          address,
          addressConstantsByAddress[address],
          addressType,
        ),
      )
      .join('\n')

    const addressList = !isUnique
      ? addressListLabel(category, addressConsts)
      : ''

    const file = [
      preamble,
      imports,
      addressTypeLabel(addressType),
      addressConstLabels,
      addressList,
      addressGuardLabel(category, addressType, isUnique, addressConsts),
      contractLabel(category, addressType, contractFactory),
      metadataTypeLabel(category, addressType, metadataType),
      metadataLabel(
        category,
        addresses,
        addressConstantsByAddress,
        metadataEntriesByAddress,
      ),
    ]
      .filter((s) => s !== '')
      .join('\n\n')

    fileByCategory[category] = prettier.format(file, {
      parser: 'typescript',
      printWidth: 80,
      tabWidth: 2,
      semi: false,
      trailingComma: 'all',
    })
    log(`\nFile %s:\n%s`, category, file)
  }
  return fileByCategory
}
