import prettier from 'prettier'
import { printNode, zodToTs } from 'zod-to-ts'
import { SonraDataModel, SonraModel } from '../schema'
import { capitalize } from '../utils'
import * as zx from '../zod'
import { Address } from '../zod'
import {
  buildSonraTrieByCategoryAndAddress,
  sonraRootTrieList,
} from './buildTrie'
import { parseMetadata } from './parseMetadata'
import { log } from '../utils'

export const categoryLabel = ({
  category,
  categoryPostFix = undefined,
  address = undefined,
  capital = false,
  postFix = false,
}: {
  category: string
  categoryPostFix?: string
  address?: zx.Address
  capital?: boolean
  postFix?: boolean
}) => {
  let label = `${category}`
  label += categoryPostFix ? `${categoryPostFix}` : ''
  label += postFix && !!address ? `_${address.slice(0, 6)}` : ''
  return capital ? capitalize(label) : label
}

const buildConstantsAddressDict = (category: string, addresses: zx.Address[]) =>
  addresses.reduce(
    (acc, address) => ({
      ...acc,
      [categoryLabel({
        category,
        address,
        postFix: true,
        categoryPostFix: 'Address',
      })]: address,
    }),
    {} as { [k in string]: zx.Address },
  )

const preamble = `// THIS FILE IS AUTOGENERATED - DO NOT EDIT`

const genImportLabel = (
  contractFactory: string,
  uniqueCategorisedAddresses: [string, string][],
) => {
  const addressImportLabels = uniqueCategorisedAddresses
    .map(
      ([importName, importPath]) =>
        `import { ${importName} } from '${importPath}';`,
    )
    .join('\n')

  return `import { Address, isAddress } from "./address"
import { ${contractFactory} } from "./contracts"
import { Signer } from "ethers";
import type { Provider } from "@ethersproject/providers";
${addressImportLabels}`
}

const genBrandedTypeLabel = (typeLabel: string) =>
  `export type ${typeLabel} = Address & { readonly ${typeLabel}: unique symbol }`

const genAddressConstantsLabel = (
  categoryTypeLabel: string,
  constantsAddressDict: { [k in string]: zx.Address },
) => {
  let label = ''

  for (const [constLabel, address] of Object.entries(constantsAddressDict)) {
    label += `const ${constLabel} = '${address}' as ${categoryTypeLabel}\n`
  }
  return label
}

const genAddressListLabel = (
  categoryAddressListConstLabel: string,
  constantsAddressDict: { [k in string]: zx.Address },
) => {
  let label = `export const ${categoryAddressListConstLabel} = [\n`
  for (const [constLabel] of Object.entries(constantsAddressDict)) {
    label += `  ${constLabel},\n`
  }
  return (label += ']')
}

const genAddressGuardFunctionLabel = (
  category: string,
  categoryTypeLabel: string,
  categoryAddressListConstLabel: string,
) => {
  const categoryMappedArgLabel = categoryLabel({
    category,
    categoryPostFix: 'Address',
  })
  return `export const is${categoryTypeLabel} = (address: string): address is ${categoryTypeLabel} =>
  isAddress(address) && ${categoryAddressListConstLabel}.some((${categoryMappedArgLabel}) => ${categoryMappedArgLabel} === address)`
}

const genContractFunctionLabel = (
  category: string,
  categoryTypeLabel: string,
  contractFactory: string,
) => {
  const contractLabel = categoryLabel({ category, categoryPostFix: 'Contract' })
  return `export const ${contractLabel} = (
  address: ${categoryTypeLabel},
  signerOrProvider: Signer | Provider) =>
  ${contractFactory}.connect(address, signerOrProvider)`
}

const genCategoryMetadataTypeLabel = (
  category: string,
  categoryTypeLabel: string,
  categoryMetadataAddressType: string,
) => {
  const typeLabel = categoryLabel({
    category,
    categoryPostFix: 'Metadata',
    capital: true,
  })

  return `export type ${typeLabel} = Record<${categoryTypeLabel}, ${categoryMetadataAddressType}>`
}

const genCategoryMetadataLabel = (
  category: string,
  constantsAddressDict: { [k in string]: zx.Address },
  metadata: SonraDataModel<SonraModel>['metadata'][string],
) => {
  const constLabel = categoryLabel({
    category,
    categoryPostFix: 'Metadata',
  })

  const typeLabel = categoryLabel({
    category,
    categoryPostFix: 'Metadata',
    capital: true,
  })

  let label = `export const ${constLabel}: ${typeLabel} = {\n`
  for (const [addressConstLabel, address] of Object.entries(
    constantsAddressDict,
  )) {
    const metadataLabel = parseMetadata(metadata[address]!)
    label += `  [${addressConstLabel}]: ${metadataLabel},\n`
  }
  return `${label}\n}`
}
export function generateFiles(
  categories: [string, ...string[]],
  model: SonraModel,
  data: SonraDataModel<SonraModel>,
  contractFactoriesByCategory: Record<string, string>,
): { [k in string]: string } {
  const sonraTrieByCategoryAndAddress = buildSonraTrieByCategoryAndAddress(
    data.metadata,
  )

  const sonraRoots = sonraRootTrieList(sonraTrieByCategoryAndAddress)
  log('sonraRoots: %O', sonraRoots)
  const uniqueCategorisedAddresses = Array.from(
    new Set(
      sonraRoots
        .filter((root) => root.label === 'CATEGORISED_ADDRESS')
        .map(({ value }) => value),
    ),
  )
    .map((x) => (x as string).split(':'))
    .map(([category, address]) => [
      categoryLabel({ category, address: address as Address, postFix: true }),
      `./${category}.ts`,
    ]) as [string, string][]

  const categoryFileDict: Record<string, string> = {}

  for (const category of categories) {
    const addresses = data.addresses[category]
    const contractFactory = contractFactoriesByCategory[category]

    const categoryTypeLabel = categoryLabel({
      category,
      capital: true,
      categoryPostFix: 'Address',
    })

    const categoryAddressListConstLabel = categoryLabel({
      category,
      categoryPostFix: 'AddressList',
    })

    const constantsAddressDict = buildConstantsAddressDict(category, addresses)

    const importLabel = genImportLabel(
      contractFactory,
      uniqueCategorisedAddresses,
    )
    const brandedTypeLabel = genBrandedTypeLabel(categoryTypeLabel)
    const addressConstantsLabel = genAddressConstantsLabel(
      categoryTypeLabel,
      constantsAddressDict,
    )
    const addressListLabel = genAddressListLabel(
      categoryAddressListConstLabel,
      constantsAddressDict,
    )
    const addressGuardFunctionLabel = genAddressGuardFunctionLabel(
      category,
      categoryTypeLabel,
      categoryAddressListConstLabel,
    )
    const contractFunctionLabel = genContractFunctionLabel(
      category,
      categoryTypeLabel,
      contractFactory,
    )

    const categoryMetadataAddressType = printNode(zodToTs(model[category]).node)

    const categoryMetadataTypeLabel = genCategoryMetadataTypeLabel(
      category,
      categoryTypeLabel,
      categoryMetadataAddressType,
    )

    const categoryMetadataLabel = genCategoryMetadataLabel(
      category,
      constantsAddressDict,
      data.metadata[category],
    )

    const file = [
      preamble,
      importLabel,
      brandedTypeLabel,
      addressConstantsLabel,
      addressListLabel,
      addressGuardFunctionLabel,
      contractFunctionLabel,
      categoryMetadataTypeLabel,
      categoryMetadataLabel,
    ].join('\n\n')

    categoryFileDict[category] = prettier.format(file, {
      parser: 'typescript',
      printWidth: 100,
      tabWidth: 2,
      semi: false,
      trailingComma: 'all',
    })
  }

  return categoryFileDict
}
